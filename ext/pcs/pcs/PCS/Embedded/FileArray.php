<?php
/*
  +----------------------------------------------------------------------+
  | PCS extension <http://pcs.tekwire.net>                               |
  +----------------------------------------------------------------------+
  | Copyright (c) 2015 The PHP Group                                     |
  +----------------------------------------------------------------------+
  | This source file is subject to version 3.01 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available through the world-wide-web at the following url:           |
  | http://www.php.net/license/3_01.txt.                                 |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Author: Francois Laupretre <francois@tekwire.net>                    |
  +----------------------------------------------------------------------+
*/
//=============================================================================
// This code is loaded by explicit request only
//PCS:LOAD=FALSE

namespace PCS\Embedded {

class FileArray
{
private $files; // Array of PCS\Embedded\File instances

public function __construct()
{
	$this->files=array();
}

/*------------------------------------------------------------------*/

function dump($prefix)
{
	usort($this->files, array("PCS\\Embedded\\File", 'sortByVpath'));

	$ret = "/* This file was generated by the PCS embedded converter */\n/*-------------------- DO NOT MODIFY --------------------*/\n\n";
	foreach($this->files as $index => $file) {
		$file->strip();
		$ret .= $file->dump_data($prefix, $index);
	}

	$ret .= "\nstatic PCS_DESCRIPTOR ".$prefix."_pcs_code[".(count($this->files) + 1)."] = {\n";
	foreach($this->files as $index => $file) {
		$ret .= $file->dump_descriptor($prefix, $index);
	}
	$ret .= "  { ".File::DESCRIPTOR_VERSION.", NULL }\n};\n";

	return $ret;
}

/*------------------------------------------------------------------*/

function register($path, $vpath)
{
	$type = filetype($path);
	if ($type === false) {
		throw new \Exception($path.": Cannot get file type");
	}

	switch($type) {
		case 'dir':
			$d=scandir($path);
			sort($d);
			foreach($d as $entry) {
				if (($entry === '.') || ($entry === '..')) {
					continue;
				}
				$epath = $path.DIRECTORY_SEPARATOR.$entry;
				$evpath = (($vpath==='') ? $entry : ($vpath.'/'.$entry));
				$this->register($epath, $evpath);
			}
			break;
	
		case 'file':
			$this->files[] = new File($path, $vpath);
			break;
	
		default:
			echo $path.": Unsupported file type ($type) - ignoring\n";
	}
}
/*------------------------------------------------------------------*/
} // End of class
//=============================================================================
} // End of namespace
?>
